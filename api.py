from flask import Flask, request, jsonify,render_template
import tensorflow as tf
import numpy as np
import json
import cv2
import math
import exe2json
import hashlib
import pefile
import os

app = Flask(__name__)
UPLOAD_FOLDER = os.path.join(os.getcwd(), "uploads")
ALLOWED_EXTENSIONS = {'exe', 'dll'}
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

model = tf.keras.Sequential([
    tf.keras.applications.EfficientNetB2(weights='imagenet', include_top=False, input_shape=(254, 254, 3)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1, activation='sigmoid')
])
model.compile(optimizer=tf.keras.optimizers.Nadam(), loss='binary_crossentropy', metrics=['accuracy'])
model.build(input_shape=(None, 254, 254, 3))
model.load_weights('best_model.weights.h5')

def get_data_from_json(file_path):
    with open(file_path) as f:
        data = json.load(f)
    json_str = json.dumps(data)
    json_bytes = json_str.encode('utf-8')
    arr = np.frombuffer(json_bytes, dtype='uint8')
    return arr

def normalize_array(arr):
    min_val = np.min(arr)
    max_val = np.max(arr)
    normalized = (arr - min_val) / (max_val - min_val) * 255
    return np.round(normalized).astype(np.uint8).flatten()

def square_array(arr):
    arr = arr[:len(arr) - len(arr) % 3]
    arr = np.array([arr[i::3] for i in range(3)]).T.flatten()
    arr = arr.reshape(-1, 3)
    side = math.ceil(math.sqrt(len(arr)))
    target_size_square = side ** 2
    if len(arr) < target_size_square:
        arr = np.pad(arr, ((0, target_size_square - len(arr)), (0, 0)), 'constant')
    return arr[:target_size_square].reshape((side, side, 3))

def reshape_array(arr, target_size=(254, 254)):
    return cv2.resize(arr, target_size, interpolation=cv2.INTER_CUBIC)

def preprocess_image_array(img_array, target_size=(254, 254)):
    image_tensor = tf.convert_to_tensor(img_array, dtype=tf.float32)
    resized_image = tf.image.resize(image_tensor, target_size, method='bicubic')
    return np.expand_dims(resized_image, axis=0)

def predict_single_image_from_array(model, img_array):
    preprocessed_img = preprocess_image_array(img_array)
    prediction = model.predict(preprocessed_img)
    predicted_label = int(np.round(prediction[0][0]))
    label_map = {0: 'benign', 1: 'malware'}
    return label_map[predicted_label], prediction[0][0]

def list_imported_api_calls(exe_path):
    pe = pefile.PE(exe_path)
    api_calls = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        for imp in entry.imports:
            dll = entry.dll.decode(errors='ignore').split(".")[0]
            api_name = f"{dll}.{imp.name.decode(errors='ignore')}" if imp.name else f"{dll}.<unknown>"
            json_call = {
                "pc": "",
                "api_name": api_name,
                "args": [],
                "ret_val": "null"
            }
            api_calls.append(json_call)
    
    return api_calls

def get_file_hash(exe_path, hash_type='sha256'):
    hash_func = hashlib.new(hash_type)
    with open(exe_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_func.update(chunk)
            
    return hash_func.hexdigest()

def getJSON(exe_path, output_path="output.json"):
    final_json = {
        "ep_type": "exe",
        "start_addr": "",
        "apihash": get_file_hash(exe_path),
        "api_calls": list_imported_api_calls(exe_path),
        "ret_val": "",
        "network_events": [],
        "error": {},
        "dynamic_code_segments": []
    }
    with open(output_path, "w") as json_file:
        json.dump(final_json, json_file, indent=4)
        
    return output_path

@app.route('/')
def home():
    return render_template("upload.html")  

@app.route('/predict', methods=['POST'])

def predict():
    print("hello")

    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected for uploading"}), 400

    if file:
        file_path = os.path.join(UPLOAD_FOLDER, file.filename)
        file.save(file_path)

        try:
            final_json_data = getJSON(file_path)
        except Exception as e:
            return jsonify({"error": str(e)}), 500
        finally:
            try:
                os.remove(file_path)
            except Exception as e:
                print(f"Warning: Could not delete the file {file_path} due to error: {e}")

        # return jsonify(final_json_data)

    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    # Process the uploaded JSON file
    array = get_data_from_json(final_json_data)
    
    if array.size > 0:
        array = normalize_array(array)
        array = square_array(array)
        reshaped_array = reshape_array(array)
        
        # Get prediction and probability
        label, probability = predict_single_image_from_array(model, reshaped_array)
        print("Prediction:", label, "Probability:", probability)
        probability = float(probability)
        return jsonify({
            'prediction': label,
            'probability': probability
        })
    else:
        return jsonify({'error': 'Invalid or empty JSON file.'}), 400

# Run the Flask app
if __name__ == '__main__':
    app.run(debug=False)
