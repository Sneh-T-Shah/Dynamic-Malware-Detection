import tensorflow as tf
import numpy as np
import json
import cv2
import math

# Load the pre-trained model and weights
model = tf.keras.Sequential([
    tf.keras.applications.EfficientNetB2(weights='imagenet', include_top=False, input_shape=(254, 254, 3)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1024, activation='relu', kernel_regularizer=tf.keras.regularizers.l1(0.01)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1, activation='sigmoid')
])
model.compile(optimizer=tf.keras.optimizers.Nadam(), loss='binary_crossentropy', metrics=['accuracy'])
model.build(input_shape=(None, 254, 254, 3))
model.load_weights('best_model.weights.h5')

# Function to read and preprocess the JSON data
def get_data_from_json(file_path):
    with open(file_path) as f:
        data = json.load(f)
    json_str = json.dumps(data)
    json_bytes = json_str.encode('utf-8')
    arr = np.frombuffer(json_bytes, dtype='uint8')
    return arr

def normalize_array(arr):
    min_val = np.min(arr)
    max_val = np.max(arr)
    normalized = (arr - min_val) / (max_val - min_val) * 255
    return np.round(normalized).astype(np.uint8).flatten()

def square_array(arr):
    arr = arr[:len(arr) - len(arr) % 3]
    arr = np.array([arr[i::3] for i in range(3)]).T.flatten()
    arr = arr.reshape(-1, 3)
    side = math.ceil(math.sqrt(len(arr)))
    target_size_square = side ** 2
    if len(arr) < target_size_square:
        arr = np.pad(arr, ((0, target_size_square - len(arr)), (0, 0)), 'constant')
    return arr[:target_size_square].reshape((side, side, 3))

def reshape_array(arr, target_size=(254, 254)):
    return cv2.resize(arr, target_size, interpolation=cv2.INTER_CUBIC)

# Preprocessing function
def preprocess_image_array(img_array, target_size=(254, 254)):
    image_tensor = tf.convert_to_tensor(img_array, dtype=tf.float32)
    resized_image = tf.image.resize(image_tensor, target_size, method='bicubic') 
    return np.expand_dims(resized_image, axis=0)

# Prediction function
def predict_single_image_from_array(model, img_array):
    preprocessed_img = preprocess_image_array(img_array)
    prediction = model.predict(preprocessed_img)
    print("Prediction:", prediction)
    predicted_label = int(np.round(prediction[0][0]))
    label_map = {0: 'benign', 1: 'malware'}
    return label_map[predicted_label]

# Main function
def predict_from_json(file_path):
    array = get_data_from_json(file_path)
    if array.size > 0:
        array = normalize_array(array)
        array = square_array(array)
        reshaped_array = reshape_array(array)
        return predict_single_image_from_array(model, reshaped_array)
    else:
        return "Invalid or empty JSON file."

# Run prediction
file_path = 'clean.json'
result = predict_from_json(file_path)
print("Prediction:", result)
